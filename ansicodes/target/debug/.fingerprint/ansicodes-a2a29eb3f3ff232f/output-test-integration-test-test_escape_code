{"$message_type":"diagnostic","message":"due to multiple output types requested, the explicitly specified output file name will be adapted for each output type","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: due to multiple output types requested, the explicitly specified output file name will be adapted for each output type\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"ignoring --out-dir flag due to -o flag","code":null,"level":"warning","spans":[],"children":[],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: ignoring --out-dir flag due to -o flag\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `CursorUp` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":506,"byte_end":514,"line_start":20,"line_end":20,"column_start":47,"column_end":55,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_up_1, super::CursorUp(1), \"\\x1B[1A\");","highlight_start":47,"highlight_end":55}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorUp;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorUp`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":499,"byte_end":506,"line_start":20,"line_end":20,"column_start":40,"column_end":47,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_up_1, super::CursorUp(1), \"\\x1B[1A\");","highlight_start":40,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `CursorUp` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:20:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_up_1, super::CursorUp(1), \"\\x1B[1A\");\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorUp;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorUp`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m20\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_up_1, \u001b[91msuper::\u001b[0mCursorUp(1), \"\\x1B[1A\");\n\u001b[1m\u001b[94m20\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_up_1, CursorUp(1), \"\\x1B[1A\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `CursorUp` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":578,"byte_end":586,"line_start":21,"line_end":21,"column_start":48,"column_end":56,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_up_23, super::CursorUp(23), \"\\x1B[23A\");","highlight_start":48,"highlight_end":56}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorUp;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorUp`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":571,"byte_end":578,"line_start":21,"line_end":21,"column_start":41,"column_end":48,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_up_23, super::CursorUp(23), \"\\x1B[23A\");","highlight_start":41,"highlight_end":48}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `CursorUp` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:21:48\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_up_23, super::CursorUp(23), \"\\x1B[23A\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                \u001b[1m\u001b[91m^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorUp;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorUp`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m21\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_up_23, \u001b[91msuper::\u001b[0mCursorUp(23), \"\\x1B[23A\");\n\u001b[1m\u001b[94m21\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_up_23, CursorUp(23), \"\\x1B[23A\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `CursorDown` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":654,"byte_end":664,"line_start":23,"line_end":23,"column_start":49,"column_end":59,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_down_1, super::CursorDown(1), \"\\x1B[1B\");","highlight_start":49,"highlight_end":59}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorDown;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorDown`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":647,"byte_end":654,"line_start":23,"line_end":23,"column_start":42,"column_end":49,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_down_1, super::CursorDown(1), \"\\x1B[1B\");","highlight_start":42,"highlight_end":49}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `CursorDown` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:23:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_down_1, super::CursorDown(1), \"\\x1B[1B\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorDown;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorDown`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m23\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_down_1, \u001b[91msuper::\u001b[0mCursorDown(1), \"\\x1B[1B\");\n\u001b[1m\u001b[94m23\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_down_1, CursorDown(1), \"\\x1B[1B\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `CursorDown` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":730,"byte_end":740,"line_start":24,"line_end":24,"column_start":50,"column_end":60,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_down_23, super::CursorDown(23), \"\\x1B[23B\");","highlight_start":50,"highlight_end":60}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorDown;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorDown`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":723,"byte_end":730,"line_start":24,"line_end":24,"column_start":43,"column_end":50,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_down_23, super::CursorDown(23), \"\\x1B[23B\");","highlight_start":43,"highlight_end":50}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `CursorDown` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:24:50\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m24\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_down_23, super::CursorDown(23), \"\\x1B[23B\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                  \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorDown;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorDown`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m24\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_down_23, \u001b[91msuper::\u001b[0mCursorDown(23), \"\\x1B[23B\");\n\u001b[1m\u001b[94m24\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_down_23, CursorDown(23), \"\\x1B[23B\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `CursorForward` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":811,"byte_end":824,"line_start":26,"line_end":26,"column_start":52,"column_end":65,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_forward_1, super::CursorForward(1), \"\\x1B[1C\");","highlight_start":52,"highlight_end":65}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorForward;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorForward`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":804,"byte_end":811,"line_start":26,"line_end":26,"column_start":45,"column_end":52,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_forward_1, super::CursorForward(1), \"\\x1B[1C\");","highlight_start":45,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `CursorForward` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:26:52\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_forward_1, super::CursorForward(1), \"\\x1B[1C\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorForward;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorForward`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_forward_1, \u001b[91msuper::\u001b[0mCursorForward(1), \"\\x1B[1C\");\n\u001b[1m\u001b[94m26\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_forward_1, CursorForward(1), \"\\x1B[1C\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `CursorForward` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":893,"byte_end":906,"line_start":27,"line_end":27,"column_start":53,"column_end":66,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_forward_23, super::CursorForward(23), \"\\x1B[23C\");","highlight_start":53,"highlight_end":66}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorForward;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorForward`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":886,"byte_end":893,"line_start":27,"line_end":27,"column_start":46,"column_end":53,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_forward_23, super::CursorForward(23), \"\\x1B[23C\");","highlight_start":46,"highlight_end":53}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `CursorForward` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:27:53\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_forward_23, super::CursorForward(23), \"\\x1B[23C\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorForward;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorForward`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m27\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_forward_23, \u001b[91msuper::\u001b[0mCursorForward(23), \"\\x1B[23C\");\n\u001b[1m\u001b[94m27\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_forward_23, CursorForward(23), \"\\x1B[23C\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `CursorBackward` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":978,"byte_end":992,"line_start":29,"line_end":29,"column_start":53,"column_end":67,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_backward_1, super::CursorBackward(1), \"\\x1B[1D\");","highlight_start":53,"highlight_end":67}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorBackward;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorBackward`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":971,"byte_end":978,"line_start":29,"line_end":29,"column_start":46,"column_end":53,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_backward_1, super::CursorBackward(1), \"\\x1B[1D\");","highlight_start":46,"highlight_end":53}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `CursorBackward` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:29:53\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_backward_1, super::CursorBackward(1), \"\\x1B[1D\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                     \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorBackward;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorBackward`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m29\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_backward_1, \u001b[91msuper::\u001b[0mCursorBackward(1), \"\\x1B[1D\");\n\u001b[1m\u001b[94m29\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_backward_1, CursorBackward(1), \"\\x1B[1D\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `CursorBackward` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1062,"byte_end":1076,"line_start":30,"line_end":30,"column_start":54,"column_end":68,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_backward_23, super::CursorBackward(23), \"\\x1B[23D\");","highlight_start":54,"highlight_end":68}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorBackward;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorBackward`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1055,"byte_end":1062,"line_start":30,"line_end":30,"column_start":47,"column_end":54,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_backward_23, super::CursorBackward(23), \"\\x1B[23D\");","highlight_start":47,"highlight_end":54}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `CursorBackward` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:30:54\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m30\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_backward_23, super::CursorBackward(23), \"\\x1B[23D\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                      \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorBackward;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorBackward`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m30\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_backward_23, \u001b[91msuper::\u001b[0mCursorBackward(23), \"\\x1B[23D\");\n\u001b[1m\u001b[94m30\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_backward_23, CursorBackward(23), \"\\x1B[23D\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CursorLeft` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1142,"byte_end":1152,"line_start":32,"line_end":32,"column_start":47,"column_end":57,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_left, super::CursorLeft, \"\\x1B[1000D\");","highlight_start":47,"highlight_end":57}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unit struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorLeft;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorLeft`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1135,"byte_end":1142,"line_start":32,"line_end":32,"column_start":40,"column_end":47,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_left, super::CursorLeft, \"\\x1B[1000D\");","highlight_start":40,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `CursorLeft` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:32:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_left, super::CursorLeft, \"\\x1B[1000D\");\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this unit struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorLeft;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorLeft`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m32\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_left, \u001b[91msuper::\u001b[0mCursorLeft, \"\\x1B[1000D\");\n\u001b[1m\u001b[94m32\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_left, CursorLeft, \"\\x1B[1000D\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CursorSavePosition` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1224,"byte_end":1242,"line_start":33,"line_end":33,"column_start":56,"column_end":74,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_save_position, super::CursorSavePosition, \"\\x1B[s\");","highlight_start":56,"highlight_end":74}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unit struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorSavePosition;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorSavePosition`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1217,"byte_end":1224,"line_start":33,"line_end":33,"column_start":49,"column_end":56,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_save_position, super::CursorSavePosition, \"\\x1B[s\");","highlight_start":49,"highlight_end":56}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `CursorSavePosition` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:33:56\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_save_position, super::CursorSavePosition, \"\\x1B[s\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                        \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this unit struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorSavePosition;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorSavePosition`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m33\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_save_position, \u001b[91msuper::\u001b[0mCursorSavePosition, \"\\x1B[s\");\n\u001b[1m\u001b[94m33\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_save_position, CursorSavePosition, \"\\x1B[s\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CursorRestorePosition` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1313,"byte_end":1334,"line_start":34,"line_end":34,"column_start":59,"column_end":80,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_restore_position, super::CursorRestorePosition, \"\\x1B[u\");","highlight_start":59,"highlight_end":80}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unit struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorRestorePosition;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorRestorePosition`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1306,"byte_end":1313,"line_start":34,"line_end":34,"column_start":52,"column_end":59,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_restore_position, super::CursorRestorePosition, \"\\x1B[u\");","highlight_start":52,"highlight_end":59}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `CursorRestorePosition` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:34:59\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_restore_position, super::CursorRestorePosition, \"\\x1B[u\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                           \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this unit struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorRestorePosition;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorRestorePosition`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m34\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_restore_position, \u001b[91msuper::\u001b[0mCursorRestorePosition, \"\\x1B[u\");\n\u001b[1m\u001b[94m34\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_restore_position, CursorRestorePosition, \"\\x1B[u\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CursorGetPosition` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1401,"byte_end":1418,"line_start":35,"line_end":35,"column_start":55,"column_end":72,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_get_position, super::CursorGetPosition, \"\\x1B[6n\");","highlight_start":55,"highlight_end":72}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unit struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorGetPosition;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorGetPosition`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1394,"byte_end":1401,"line_start":35,"line_end":35,"column_start":48,"column_end":55,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_get_position, super::CursorGetPosition, \"\\x1B[6n\");","highlight_start":48,"highlight_end":55}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `CursorGetPosition` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:35:55\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_get_position, super::CursorGetPosition, \"\\x1B[6n\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this unit struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorGetPosition;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorGetPosition`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m35\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_get_position, \u001b[91msuper::\u001b[0mCursorGetPosition, \"\\x1B[6n\");\n\u001b[1m\u001b[94m35\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_get_position, CursorGetPosition, \"\\x1B[6n\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CursorNextLine` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1483,"byte_end":1497,"line_start":36,"line_end":36,"column_start":52,"column_end":66,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_next_line, super::CursorNextLine, \"\\x1B[E\");","highlight_start":52,"highlight_end":66}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unit struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorNextLine;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorNextLine`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1476,"byte_end":1483,"line_start":36,"line_end":36,"column_start":45,"column_end":52,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_next_line, super::CursorNextLine, \"\\x1B[E\");","highlight_start":45,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `CursorNextLine` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:36:52\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_next_line, super::CursorNextLine, \"\\x1B[E\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this unit struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorNextLine;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorNextLine`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m36\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_next_line, \u001b[91msuper::\u001b[0mCursorNextLine, \"\\x1B[E\");\n\u001b[1m\u001b[94m36\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_next_line, CursorNextLine, \"\\x1B[E\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CursorPrevLine` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1561,"byte_end":1575,"line_start":37,"line_end":37,"column_start":52,"column_end":66,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_prev_line, super::CursorPrevLine, \"\\x1B[F\");","highlight_start":52,"highlight_end":66}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unit struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorPrevLine;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorPrevLine`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1554,"byte_end":1561,"line_start":37,"line_end":37,"column_start":45,"column_end":52,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_prev_line, super::CursorPrevLine, \"\\x1B[F\");","highlight_start":45,"highlight_end":52}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `CursorPrevLine` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:37:52\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_prev_line, super::CursorPrevLine, \"\\x1B[F\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                    \u001b[1m\u001b[91m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this unit struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorPrevLine;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorPrevLine`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m37\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_prev_line, \u001b[91msuper::\u001b[0mCursorPrevLine, \"\\x1B[F\");\n\u001b[1m\u001b[94m37\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_prev_line, CursorPrevLine, \"\\x1B[F\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CursorHide` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1634,"byte_end":1644,"line_start":38,"line_end":38,"column_start":47,"column_end":57,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_hide, super::CursorHide, \"\\x1B[?25l\");","highlight_start":47,"highlight_end":57}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unit struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorHide;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorHide`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1627,"byte_end":1634,"line_start":38,"line_end":38,"column_start":40,"column_end":47,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_hide, super::CursorHide, \"\\x1B[?25l\");","highlight_start":40,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `CursorHide` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:38:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_hide, super::CursorHide, \"\\x1B[?25l\");\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this unit struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorHide;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorHide`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m38\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_hide, \u001b[91msuper::\u001b[0mCursorHide, \"\\x1B[?25l\");\n\u001b[1m\u001b[94m38\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_hide, CursorHide, \"\\x1B[?25l\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find value `CursorShow` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1706,"byte_end":1716,"line_start":39,"line_end":39,"column_start":47,"column_end":57,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_show, super::CursorShow, \"\\x1B[?25h\");","highlight_start":47,"highlight_end":57}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this unit struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::CursorShow;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `CursorShow`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1699,"byte_end":1706,"line_start":39,"line_end":39,"column_start":40,"column_end":47,"is_primary":true,"text":[{"text":"    assert_escape_output!(cursor_show, super::CursorShow, \"\\x1B[?25h\");","highlight_start":40,"highlight_end":47}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find value `CursorShow` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:39:47\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(cursor_show, super::CursorShow, \"\\x1B[?25h\");\n   \u001b[1m\u001b[94m|\u001b[0m                                               \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this unit struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::CursorShow;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `CursorShow`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(cursor_show, \u001b[91msuper::\u001b[0mCursorShow, \"\\x1B[?25h\");\n\u001b[1m\u001b[94m39\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(cursor_show, CursorShow, \"\\x1B[?25h\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `EraseLines` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1781,"byte_end":1791,"line_start":41,"line_end":41,"column_start":49,"column_end":59,"is_primary":true,"text":[{"text":"    assert_escape_output!(erase_lines_1, super::EraseLines(1), \"\\x1B[1000D\\x1B[K\");","highlight_start":49,"highlight_end":59}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::EraseLines;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `EraseLines`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1774,"byte_end":1781,"line_start":41,"line_end":41,"column_start":42,"column_end":49,"is_primary":true,"text":[{"text":"    assert_escape_output!(erase_lines_1, super::EraseLines(1), \"\\x1B[1000D\\x1B[K\");","highlight_start":42,"highlight_end":49}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `EraseLines` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:41:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m41\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(erase_lines_1, super::EraseLines(1), \"\\x1B[1000D\\x1B[K\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::EraseLines;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `EraseLines`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m41\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(erase_lines_1, \u001b[91msuper::\u001b[0mEraseLines(1), \"\\x1B[1000D\\x1B[K\");\n\u001b[1m\u001b[94m41\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(erase_lines_1, EraseLines(1), \"\\x1B[1000D\\x1B[K\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `EraseLines` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1865,"byte_end":1875,"line_start":42,"line_end":42,"column_start":49,"column_end":59,"is_primary":true,"text":[{"text":"    assert_escape_output!(erase_lines_2, super::EraseLines(2), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");","highlight_start":49,"highlight_end":59}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::EraseLines;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `EraseLines`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1858,"byte_end":1865,"line_start":42,"line_end":42,"column_start":42,"column_end":49,"is_primary":true,"text":[{"text":"    assert_escape_output!(erase_lines_2, super::EraseLines(2), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");","highlight_start":42,"highlight_end":49}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `EraseLines` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:42:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(erase_lines_2, super::EraseLines(2), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::EraseLines;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `EraseLines`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(erase_lines_2, \u001b[91msuper::\u001b[0mEraseLines(2), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");\n\u001b[1m\u001b[94m42\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(erase_lines_2, EraseLines(2), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"cannot find function, tuple struct or tuple variant `EraseLines` in module `super`","code":{"code":"E0425","explanation":"An unresolved name was used.\n\nErroneous code examples:\n\n```compile_fail,E0425\nsomething_that_doesnt_exist::foo;\n// error: unresolved name `something_that_doesnt_exist::foo`\n\n// or:\n\ntrait Foo {\n    fn bar() {\n        Self; // error: unresolved name `Self`\n    }\n}\n\n// or:\n\nlet x = unknown_variable;  // error: unresolved name `unknown_variable`\n```\n\nPlease verify that the name wasn't misspelled and ensure that the\nidentifier being referred to is valid for the given situation. Example:\n\n```\nenum something_that_does_exist {\n    Foo,\n}\n```\n\nOr:\n\n```\nmod something_that_does_exist {\n    pub static foo : i32 = 0i32;\n}\n\nsomething_that_does_exist::foo; // ok!\n```\n\nOr:\n\n```\nlet unknown_variable = 12u32;\nlet x = unknown_variable; // ok!\n```\n\nIf the item is not defined in the current module, it must be imported using a\n`use` statement, like so:\n\n```\n# mod foo { pub fn bar() {} }\n# fn main() {\nuse foo::bar;\nbar();\n# }\n```\n\nIf the item you are importing is not defined in some super-module of the\ncurrent module, then it must also be declared as public (e.g., `pub fn`).\n"},"level":"error","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1972,"byte_end":1982,"line_start":43,"line_end":43,"column_start":49,"column_end":59,"is_primary":true,"text":[{"text":"    assert_escape_output!(erase_lines_3, super::EraseLines(3), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");","highlight_start":49,"highlight_end":59}],"label":"not found in `super`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider importing this tuple struct","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":36,"byte_end":36,"line_start":5,"line_end":5,"column_start":5,"column_end":5,"is_primary":true,"text":[{"text":"    use std::{io::Write, string::String, vec::Vec};","highlight_start":5,"highlight_end":5}],"label":null,"suggested_replacement":"use ansicodes::EraseLines;\n","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null},{"message":"if you import `EraseLines`, refer to it directly","code":null,"level":"help","spans":[{"file_name":"tests/test_escape_code.rs","byte_start":1965,"byte_end":1972,"line_start":43,"line_end":43,"column_start":42,"column_end":49,"is_primary":true,"text":[{"text":"    assert_escape_output!(erase_lines_3, super::EraseLines(3), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");","highlight_start":42,"highlight_end":49}],"label":null,"suggested_replacement":"","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0425]\u001b[0m\u001b[1m: cannot find function, tuple struct or tuple variant `EraseLines` in module `super`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0mtests/test_escape_code.rs:43:49\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     assert_escape_output!(erase_lines_3, super::EraseLines(3), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");\n   \u001b[1m\u001b[94m|\u001b[0m                                                 \u001b[1m\u001b[91m^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mnot found in `super`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider importing this tuple struct\n   \u001b[1m\u001b[94m|\u001b[0m\n \u001b[1m\u001b[94m5\u001b[0m \u001b[92m+ \u001b[0m    \u001b[92muse ansicodes::EraseLines;\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: if you import `EraseLines`, refer to it directly\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m43\u001b[0m \u001b[91m- \u001b[0m    assert_escape_output!(erase_lines_3, \u001b[91msuper::\u001b[0mEraseLines(3), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");\n\u001b[1m\u001b[94m43\u001b[0m \u001b[92m+ \u001b[0m    assert_escape_output!(erase_lines_3, EraseLines(3), \"\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\\x1B[1A\\x1B[1000D\\x1B[K\");\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 19 previous errors; 2 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 19 previous errors; 2 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0425`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about this error, try `rustc --explain E0425`.\u001b[0m\n"}
